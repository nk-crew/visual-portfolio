{"version":3,"file":"fjGallery.min.js","sources":["../src/utils/global.js","../node_modules/throttle-debounce/esm/index.js","../node_modules/raf-schd/dist/raf-schd.esm.js","../node_modules/justified-layout/lib/row.js","../node_modules/justified-layout/lib/index.js","../src/utils/get-img-dimensions.js","../src/fjGallery.js","../src/utils/ready.js","../src/fjGallery.umd.js"],"sourcesContent":["/* eslint-disable import/no-mutable-exports */\n/* eslint-disable no-restricted-globals */\nlet win;\n\nif ('undefined' !== typeof window) {\n  win = window;\n} else if ('undefined' !== typeof global) {\n  win = global;\n} else if ('undefined' !== typeof self) {\n  win = self;\n} else {\n  win = {};\n}\n\nexport default win;\n","/* eslint-disable no-undefined,no-param-reassign,no-shadow */\n\n/**\n * Throttle execution of a function. Especially useful for rate limiting\n * execution of handlers on events like resize and scroll.\n *\n * @param {number} delay -                  A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher)\n *                                            are most useful.\n * @param {Function} callback -               A function to be executed after delay milliseconds. The `this` context and all arguments are passed through,\n *                                            as-is, to `callback` when the throttled-function is executed.\n * @param {object} [options] -              An object to configure options.\n * @param {boolean} [options.noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds\n *                                            while the throttled-function is being called. If noTrailing is false or unspecified, callback will be executed\n *                                            one final time after the last throttled-function call. (After the throttled-function has not been called for\n *                                            `delay` milliseconds, the internal counter is reset).\n * @param {boolean} [options.noLeading] -   Optional, defaults to false. If noLeading is false, the first throttled-function call will execute callback\n *                                            immediately. If noLeading is true, the first the callback execution will be skipped. It should be noted that\n *                                            callback will never executed if both noLeading = true and noTrailing = true.\n * @param {boolean} [options.debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is\n *                                            false (at end), schedule `callback` to execute after `delay` ms.\n *\n * @returns {Function} A new, throttled, function.\n */\nfunction throttle (delay, callback, options) {\n  var _ref = options || {},\n      _ref$noTrailing = _ref.noTrailing,\n      noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing,\n      _ref$noLeading = _ref.noLeading,\n      noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading,\n      _ref$debounceMode = _ref.debounceMode,\n      debounceMode = _ref$debounceMode === void 0 ? undefined : _ref$debounceMode;\n  /*\n   * After wrapper has stopped being called, this timeout ensures that\n   * `callback` is executed at the proper times in `throttle` and `end`\n   * debounce modes.\n   */\n\n\n  var timeoutID;\n  var cancelled = false; // Keep track of the last time `callback` was executed.\n\n  var lastExec = 0; // Function to clear existing timeout\n\n  function clearExistingTimeout() {\n    if (timeoutID) {\n      clearTimeout(timeoutID);\n    }\n  } // Function to cancel next exec\n\n\n  function cancel(options) {\n    var _ref2 = options || {},\n        _ref2$upcomingOnly = _ref2.upcomingOnly,\n        upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;\n\n    clearExistingTimeout();\n    cancelled = !upcomingOnly;\n  }\n  /*\n   * The `wrapper` function encapsulates all of the throttling / debouncing\n   * functionality and when executed will limit the rate at which `callback`\n   * is executed.\n   */\n\n\n  function wrapper() {\n    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {\n      arguments_[_key] = arguments[_key];\n    }\n\n    var self = this;\n    var elapsed = Date.now() - lastExec;\n\n    if (cancelled) {\n      return;\n    } // Execute `callback` and update the `lastExec` timestamp.\n\n\n    function exec() {\n      lastExec = Date.now();\n      callback.apply(self, arguments_);\n    }\n    /*\n     * If `debounceMode` is true (at begin) this is used to clear the flag\n     * to allow future `callback` executions.\n     */\n\n\n    function clear() {\n      timeoutID = undefined;\n    }\n\n    if (!noLeading && debounceMode && !timeoutID) {\n      /*\n       * Since `wrapper` is being called for the first time and\n       * `debounceMode` is true (at begin), execute `callback`\n       * and noLeading != true.\n       */\n      exec();\n    }\n\n    clearExistingTimeout();\n\n    if (debounceMode === undefined && elapsed > delay) {\n      if (noLeading) {\n        /*\n         * In throttle mode with noLeading, if `delay` time has\n         * been exceeded, update `lastExec` and schedule `callback`\n         * to execute after `delay` ms.\n         */\n        lastExec = Date.now();\n\n        if (!noTrailing) {\n          timeoutID = setTimeout(debounceMode ? clear : exec, delay);\n        }\n      } else {\n        /*\n         * In throttle mode without noLeading, if `delay` time has been exceeded, execute\n         * `callback`.\n         */\n        exec();\n      }\n    } else if (noTrailing !== true) {\n      /*\n       * In trailing throttle mode, since `delay` time has not been\n       * exceeded, schedule `callback` to execute `delay` ms after most\n       * recent execution.\n       *\n       * If `debounceMode` is true (at begin), schedule `clear` to execute\n       * after `delay` ms.\n       *\n       * If `debounceMode` is false (at end), schedule `callback` to\n       * execute after `delay` ms.\n       */\n      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);\n    }\n  }\n\n  wrapper.cancel = cancel; // Return the wrapper function.\n\n  return wrapper;\n}\n\n/* eslint-disable no-undefined */\n/**\n * Debounce execution of a function. Debouncing, unlike throttling,\n * guarantees that a function is only executed a single time, either at the\n * very beginning of a series of calls, or at the very end.\n *\n * @param {number} delay -               A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param {Function} callback -          A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                        to `callback` when the debounced-function is executed.\n * @param {object} [options] -           An object to configure options.\n * @param {boolean} [options.atBegin] -  Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds\n *                                        after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.\n *                                        (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).\n *\n * @returns {Function} A new, debounced function.\n */\n\nfunction debounce (delay, callback, options) {\n  var _ref = options || {},\n      _ref$atBegin = _ref.atBegin,\n      atBegin = _ref$atBegin === void 0 ? false : _ref$atBegin;\n\n  return throttle(delay, callback, {\n    debounceMode: atBegin !== false\n  });\n}\n\nexport { debounce, throttle };\n//# sourceMappingURL=index.js.map\n","var rafSchd = function rafSchd(fn) {\n  var lastArgs = [];\n  var frameId = null;\n\n  var wrapperFn = function wrapperFn() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    lastArgs = args;\n\n    if (frameId) {\n      return;\n    }\n\n    frameId = requestAnimationFrame(function () {\n      frameId = null;\n      fn.apply(void 0, lastArgs);\n    });\n  };\n\n  wrapperFn.cancel = function () {\n    if (!frameId) {\n      return;\n    }\n\n    cancelAnimationFrame(frameId);\n    frameId = null;\n  };\n\n  return wrapperFn;\n};\n\nexport default rafSchd;\n","/*!\n * Copyright 2019 SmugMug, Inc.\n * Licensed under the terms of the MIT license. Please see LICENSE file in the project root for terms.\n * @license\n */\n\n/**\n * Row\n * Wrapper for each row in a justified layout.\n * Stores relevant values and provides methods for calculating layout of individual rows.\n *\n * @param {Object} layoutConfig - The same as that passed\n * @param {Object} Initialization parameters. The following are all required:\n * @param params.top {Number} Top of row, relative to container\n * @param params.left {Number} Left side of row relative to container (equal to container left padding)\n * @param params.width {Number} Width of row, not including container padding\n * @param params.spacing {Number} Horizontal spacing between items\n * @param params.targetRowHeight {Number} Layout algorithm will aim for this row height\n * @param params.targetRowHeightTolerance {Number} Row heights may vary +/- (`targetRowHeight` x `targetRowHeightTolerance`)\n * @param params.edgeCaseMinRowHeight {Number} Absolute minimum row height for edge cases that cannot be resolved within tolerance.\n * @param params.edgeCaseMaxRowHeight {Number} Absolute maximum row height for edge cases that cannot be resolved within tolerance.\n * @param params.isBreakoutRow {Boolean} Is this row in particular one of those breakout rows? Always false if it's not that kind of photo list\n * @param params.widowLayoutStyle {String} If widows are visible, how should they be laid out?\n * @constructor\n */\n\nvar Row = module.exports = function (params) {\n\n\t// Top of row, relative to container\n\tthis.top = params.top;\n\n\t// Left side of row relative to container (equal to container left padding)\n\tthis.left = params.left;\n\n\t// Width of row, not including container padding\n\tthis.width = params.width;\n\n\t// Horizontal spacing between items\n\tthis.spacing = params.spacing;\n\n\t// Row height calculation values\n\tthis.targetRowHeight = params.targetRowHeight;\n\tthis.targetRowHeightTolerance = params.targetRowHeightTolerance;\n\tthis.minAspectRatio = this.width / params.targetRowHeight * (1 - params.targetRowHeightTolerance);\n\tthis.maxAspectRatio = this.width / params.targetRowHeight * (1 + params.targetRowHeightTolerance);\n\n\t// Edge case row height minimum/maximum\n\tthis.edgeCaseMinRowHeight = params.edgeCaseMinRowHeight;\n\tthis.edgeCaseMaxRowHeight = params.edgeCaseMaxRowHeight;\n\n\t// Widow layout direction\n\tthis.widowLayoutStyle = params.widowLayoutStyle;\n\n\t// Full width breakout rows\n\tthis.isBreakoutRow = params.isBreakoutRow;\n\n\t// Store layout data for each item in row\n\tthis.items = [];\n\n\t// Height remains at 0 until it's been calculated\n\tthis.height = 0;\n\n};\n\nRow.prototype = {\n\n\t/**\n\t * Attempt to add a single item to the row.\n\t * This is the heart of the justified algorithm.\n\t * This method is direction-agnostic; it deals only with sizes, not positions.\n\t *\n\t * If the item fits in the row, without pushing row height beyond min/max tolerance,\n\t * the item is added and the method returns true.\n\t *\n\t * If the item leaves row height too high, there may be room to scale it down and add another item.\n\t * In this case, the item is added and the method returns true, but the row is incomplete.\n\t *\n\t * If the item leaves row height too short, there are too many items to fit within tolerance.\n\t * The method will either accept or reject the new item, favoring the resulting row height closest to within tolerance.\n\t * If the item is rejected, left/right padding will be required to fit the row height within tolerance;\n\t * if the item is accepted, top/bottom cropping will be required to fit the row height within tolerance.\n\t *\n\t * @method addItem\n\t * @param itemData {Object} Item layout data, containing item aspect ratio.\n\t * @return {Boolean} True if successfully added; false if rejected.\n\t */\n\n\taddItem: function (itemData) {\n\n\t\tvar newItems = this.items.concat(itemData),\n\t\t\t// Calculate aspect ratios for items only; exclude spacing\n\t\t\trowWidthWithoutSpacing = this.width - (newItems.length - 1) * this.spacing,\n\t\t\tnewAspectRatio = newItems.reduce(function (sum, item) {\n\t\t\t\treturn sum + item.aspectRatio;\n\t\t\t}, 0),\n\t\t\ttargetAspectRatio = rowWidthWithoutSpacing / this.targetRowHeight,\n\t\t\tpreviousRowWidthWithoutSpacing,\n\t\t\tpreviousAspectRatio,\n\t\t\tpreviousTargetAspectRatio;\n\n\t\t// Handle big full-width breakout photos if we're doing them\n\t\tif (this.isBreakoutRow) {\n\t\t\t// Only do it if there's no other items in this row\n\t\t\tif (this.items.length === 0) {\n\t\t\t\t// Only go full width if this photo is a square or landscape\n\t\t\t\tif (itemData.aspectRatio >= 1) {\n\t\t\t\t\t// Close out the row with a full width photo\n\t\t\t\t\tthis.items.push(itemData);\n\t\t\t\t\tthis.completeLayout(rowWidthWithoutSpacing / itemData.aspectRatio, 'justify');\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (newAspectRatio < this.minAspectRatio) {\n\n\t\t\t// New aspect ratio is too narrow / scaled row height is too tall.\n\t\t\t// Accept this item and leave row open for more items.\n\n\t\t\tthis.items.push(Object.assign({}, itemData));\n\t\t\treturn true;\n\n\t\t} else if (newAspectRatio > this.maxAspectRatio) {\n\n\t\t\t// New aspect ratio is too wide / scaled row height will be too short.\n\t\t\t// Accept item if the resulting aspect ratio is closer to target than it would be without the item.\n\t\t\t// NOTE: Any row that falls into this block will require cropping/padding on individual items.\n\n\t\t\tif (this.items.length === 0) {\n\n\t\t\t\t// When there are no existing items, force acceptance of the new item and complete the layout.\n\t\t\t\t// This is the pano special case.\n\t\t\t\tthis.items.push(Object.assign({}, itemData));\n\t\t\t\tthis.completeLayout(rowWidthWithoutSpacing / newAspectRatio, 'justify');\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\t// Calculate width/aspect ratio for row before adding new item\n\t\t\tpreviousRowWidthWithoutSpacing = this.width - (this.items.length - 1) * this.spacing;\n\t\t\tpreviousAspectRatio = this.items.reduce(function (sum, item) {\n\t\t\t\treturn sum + item.aspectRatio;\n\t\t\t}, 0);\n\t\t\tpreviousTargetAspectRatio = previousRowWidthWithoutSpacing / this.targetRowHeight;\n\n\t\t\tif (Math.abs(newAspectRatio - targetAspectRatio) > Math.abs(previousAspectRatio - previousTargetAspectRatio)) {\n\n\t\t\t\t// Row with new item is us farther away from target than row without; complete layout and reject item.\n\t\t\t\tthis.completeLayout(previousRowWidthWithoutSpacing / previousAspectRatio, 'justify');\n\t\t\t\treturn false;\n\n\t\t\t} else {\n\n\t\t\t\t// Row with new item is us closer to target than row without;\n\t\t\t\t// accept the new item and complete the row layout.\n\t\t\t\tthis.items.push(Object.assign({}, itemData));\n\t\t\t\tthis.completeLayout(rowWidthWithoutSpacing / newAspectRatio, 'justify');\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// New aspect ratio / scaled row height is within tolerance;\n\t\t\t// accept the new item and complete the row layout.\n\t\t\tthis.items.push(Object.assign({}, itemData));\n\t\t\tthis.completeLayout(rowWidthWithoutSpacing / newAspectRatio, 'justify');\n\t\t\treturn true;\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Check if a row has completed its layout.\n\t *\n\t * @method isLayoutComplete\n\t * @return {Boolean} True if complete; false if not.\n\t */\n\n\tisLayoutComplete: function () {\n\t\treturn this.height > 0;\n\t},\n\n\t/**\n\t * Set row height and compute item geometry from that height.\n\t * Will justify items within the row unless instructed not to.\n\t *\n\t * @method completeLayout\n\t * @param newHeight {Number} Set row height to this value.\n\t * @param widowLayoutStyle {String} How should widows display? Supported: left | justify | center\n\t */\n\n\tcompleteLayout: function (newHeight, widowLayoutStyle) {\n\n\t\tvar itemWidthSum = this.left,\n\t\t\trowWidthWithoutSpacing = this.width - (this.items.length - 1) * this.spacing,\n\t\t\tclampedToNativeRatio,\n\t\t\tclampedHeight,\n\t\t\terrorWidthPerItem,\n\t\t\troundedCumulativeErrors,\n\t\t\tsingleItemGeometry,\n\t\t\tcenterOffset;\n\n\t\t// Justify unless explicitly specified otherwise.\n\t\tif (typeof widowLayoutStyle === 'undefined' || ['justify', 'center', 'left'].indexOf(widowLayoutStyle) < 0) {\n\t\t\twidowLayoutStyle = 'left';\n\t\t}\n\n\t\t// Clamp row height to edge case minimum/maximum.\n\t\tclampedHeight = Math.max(this.edgeCaseMinRowHeight, Math.min(newHeight, this.edgeCaseMaxRowHeight));\n\n\t\tif (newHeight !== clampedHeight) {\n\n\t\t\t// If row height was clamped, the resulting row/item aspect ratio will be off,\n\t\t\t// so force it to fit the width (recalculate aspectRatio to match clamped height).\n\t\t\t// NOTE: this will result in cropping/padding commensurate to the amount of clamping.\n\t\t\tthis.height = clampedHeight;\n\t\t\tclampedToNativeRatio = (rowWidthWithoutSpacing / clampedHeight) / (rowWidthWithoutSpacing / newHeight);\n\n\t\t} else {\n\n\t\t\t// If not clamped, leave ratio at 1.0.\n\t\t\tthis.height = newHeight;\n\t\t\tclampedToNativeRatio = 1.0;\n\n\t\t}\n\n\t\t// Compute item geometry based on newHeight.\n\t\tthis.items.forEach(function (item) {\n\n\t\t\titem.top = this.top;\n\t\t\titem.width = item.aspectRatio * this.height * clampedToNativeRatio;\n\t\t\titem.height = this.height;\n\n\t\t\t// Left-to-right.\n\t\t\t// TODO right to left\n\t\t\t// item.left = this.width - itemWidthSum - item.width;\n\t\t\titem.left = itemWidthSum;\n\n\t\t\t// Increment width.\n\t\t\titemWidthSum += item.width + this.spacing;\n\n\t\t}, this);\n\n\t\t// If specified, ensure items fill row and distribute error\n\t\t// caused by rounding width and height across all items.\n\t\tif (widowLayoutStyle === 'justify') {\n\n\t\t\titemWidthSum -= (this.spacing + this.left);\n\n\t\t\terrorWidthPerItem = (itemWidthSum - this.width) / this.items.length;\n\t\t\troundedCumulativeErrors = this.items.map(function (item, i) {\n\t\t\t\treturn Math.round((i + 1) * errorWidthPerItem);\n\t\t\t});\n\n\n\t\t\tif (this.items.length === 1) {\n\n\t\t\t\t// For rows with only one item, adjust item width to fill row.\n\t\t\t\tsingleItemGeometry = this.items[0];\n\t\t\t\tsingleItemGeometry.width -= Math.round(errorWidthPerItem);\n\n\t\t\t} else {\n\n\t\t\t\t// For rows with multiple items, adjust item width and shift items to fill the row,\n\t\t\t\t// while maintaining equal spacing between items in the row.\n\t\t\t\tthis.items.forEach(function (item, i) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\titem.left -= roundedCumulativeErrors[i - 1];\n\t\t\t\t\t\titem.width -= (roundedCumulativeErrors[i] - roundedCumulativeErrors[i - 1]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\titem.width -= roundedCumulativeErrors[i];\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t}\n\n\t\t} else if (widowLayoutStyle === 'center') {\n\n\t\t\t// Center widows\n\t\t\tcenterOffset = (this.width - itemWidthSum) / 2;\n\n\t\t\tthis.items.forEach(function (item) {\n\t\t\t\titem.left += centerOffset + this.spacing;\n\t\t\t}, this);\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Force completion of row layout with current items.\n\t *\n\t * @method forceComplete\n\t * @param fitToWidth {Boolean} Stretch current items to fill the row width.\n\t *                             This will likely result in padding.\n\t * @param fitToWidth {Number}\n\t */\n\n\tforceComplete: function (fitToWidth, rowHeight) {\n\n\t\t// TODO Handle fitting to width\n\t\t// var rowWidthWithoutSpacing = this.width - (this.items.length - 1) * this.spacing,\n\t\t// \tcurrentAspectRatio = this.items.reduce(function (sum, item) {\n\t\t// \t\treturn sum + item.aspectRatio;\n\t\t// \t}, 0);\n\n\t\tif (typeof rowHeight === 'number') {\n\n\t\t\tthis.completeLayout(rowHeight, this.widowLayoutStyle);\n\n\t\t} else {\n\n\t\t\t// Complete using target row height.\n\t\t\tthis.completeLayout(this.targetRowHeight, this.widowLayoutStyle);\n\t\t}\n\n\t},\n\n\t/**\n\t * Return layout data for items within row.\n\t * Note: returns actual list, not a copy.\n\t *\n\t * @method getItems\n\t * @return Layout data for items within row.\n\t */\n\n\tgetItems: function () {\n\t\treturn this.items;\n\t}\n\n};\n","/*!\n * Copyright 2019 SmugMug, Inc.\n * Licensed under the terms of the MIT license. Please see LICENSE file in the project root for terms.\n * @license\n */\n\n'use strict';\n\nvar Row = require('./row');\n\n/**\n * Create a new, empty row.\n *\n * @method createNewRow\n * @param layoutConfig {Object} The layout configuration\n * @param layoutData {Object} The current state of the layout\n * @return A new, empty row of the type specified by this layout.\n */\n\nfunction createNewRow(layoutConfig, layoutData) {\n\n\tvar isBreakoutRow;\n\n\t// Work out if this is a full width breakout row\n\tif (layoutConfig.fullWidthBreakoutRowCadence !== false) {\n\t\tif (((layoutData._rows.length + 1) % layoutConfig.fullWidthBreakoutRowCadence) === 0) {\n\t\t\tisBreakoutRow = true;\n\t\t}\n\t}\n\n\treturn new Row({\n\t\ttop: layoutData._containerHeight,\n\t\tleft: layoutConfig.containerPadding.left,\n\t\twidth: layoutConfig.containerWidth - layoutConfig.containerPadding.left - layoutConfig.containerPadding.right,\n\t\tspacing: layoutConfig.boxSpacing.horizontal,\n\t\ttargetRowHeight: layoutConfig.targetRowHeight,\n\t\ttargetRowHeightTolerance: layoutConfig.targetRowHeightTolerance,\n\t\tedgeCaseMinRowHeight: 0.5 * layoutConfig.targetRowHeight,\n\t\tedgeCaseMaxRowHeight: 2 * layoutConfig.targetRowHeight,\n\t\trightToLeft: false,\n\t\tisBreakoutRow: isBreakoutRow,\n\t\twidowLayoutStyle: layoutConfig.widowLayoutStyle\n\t});\n}\n\n/**\n * Add a completed row to the layout.\n * Note: the row must have already been completed.\n *\n * @method addRow\n * @param layoutConfig {Object} The layout configuration\n * @param layoutData {Object} The current state of the layout\n * @param row {Row} The row to add.\n * @return {Array} Each item added to the row.\n */\n\nfunction addRow(layoutConfig, layoutData, row) {\n\n\tlayoutData._rows.push(row);\n\tlayoutData._layoutItems = layoutData._layoutItems.concat(row.getItems());\n\n\t// Increment the container height\n\tlayoutData._containerHeight += row.height + layoutConfig.boxSpacing.vertical;\n\n\treturn row.items;\n}\n\n/**\n * Calculate the current layout for all items in the list that require layout.\n * \"Layout\" means geometry: position within container and size\n *\n * @method computeLayout\n * @param layoutConfig {Object} The layout configuration\n * @param layoutData {Object} The current state of the layout\n * @param itemLayoutData {Array} Array of items to lay out, with data required to lay out each item\n * @return {Object} The newly-calculated layout, containing the new container height, and lists of layout items\n */\n\nfunction computeLayout(layoutConfig, layoutData, itemLayoutData) {\n\n\tvar laidOutItems = [],\n\t\titemAdded,\n\t\tcurrentRow,\n\t\tnextToLastRowHeight;\n\n\t// Apply forced aspect ratio if specified, and set a flag.\n\tif (layoutConfig.forceAspectRatio) {\n\t\titemLayoutData.forEach(function (itemData) {\n\t\t\titemData.forcedAspectRatio = true;\n\t\t\titemData.aspectRatio = layoutConfig.forceAspectRatio;\n\t\t});\n\t}\n\n\t// Loop through the items\n\titemLayoutData.some(function (itemData, i) {\n\n\t\tif (isNaN(itemData.aspectRatio)) {\n\t\t\tthrow new Error(\"Item \" + i + \" has an invalid aspect ratio\");\n\t\t}\n\n\t\t// If not currently building up a row, make a new one.\n\t\tif (!currentRow) {\n\t\t\tcurrentRow = createNewRow(layoutConfig, layoutData);\n\t\t}\n\n\t\t// Attempt to add item to the current row.\n\t\titemAdded = currentRow.addItem(itemData);\n\n\t\tif (currentRow.isLayoutComplete()) {\n\n\t\t\t// Row is filled; add it and start a new one\n\t\t\tlaidOutItems = laidOutItems.concat(addRow(layoutConfig, layoutData, currentRow));\n\n\t\t\tif (layoutData._rows.length >= layoutConfig.maxNumRows) {\n\t\t\t\tcurrentRow = null;\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tcurrentRow = createNewRow(layoutConfig, layoutData);\n\n\t\t\t// Item was rejected; add it to its own row\n\t\t\tif (!itemAdded) {\n\n\t\t\t\titemAdded = currentRow.addItem(itemData);\n\n\t\t\t\tif (currentRow.isLayoutComplete()) {\n\n\t\t\t\t\t// If the rejected item fills a row on its own, add the row and start another new one\n\t\t\t\t\tlaidOutItems = laidOutItems.concat(addRow(layoutConfig, layoutData, currentRow));\n\t\t\t\t\tif (layoutData._rows.length >= layoutConfig.maxNumRows) {\n\t\t\t\t\t\tcurrentRow = null;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcurrentRow = createNewRow(layoutConfig, layoutData);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t});\n\n\t// Handle any leftover content (orphans) depending on where they lie\n\t// in this layout update, and in the total content set.\n\tif (currentRow && currentRow.getItems().length && layoutConfig.showWidows) {\n\n\t\t// Last page of all content or orphan suppression is suppressed; lay out orphans.\n\t\tif (layoutData._rows.length) {\n\n\t\t\t// Only Match previous row's height if it exists and it isn't a breakout row\n\t\t\tif (layoutData._rows[layoutData._rows.length - 1].isBreakoutRow) {\n\t\t\t\tnextToLastRowHeight = layoutData._rows[layoutData._rows.length - 1].targetRowHeight;\n\t\t\t} else {\n\t\t\t\tnextToLastRowHeight = layoutData._rows[layoutData._rows.length - 1].height;\n\t\t\t}\n\n\t\t\tcurrentRow.forceComplete(false, nextToLastRowHeight);\n\n\t\t} else {\n\n\t\t\t// ...else use target height if there is no other row height to reference.\n\t\t\tcurrentRow.forceComplete(false);\n\n\t\t}\n\n\t\tlaidOutItems = laidOutItems.concat(addRow(layoutConfig, layoutData, currentRow));\n\t\tlayoutConfig._widowCount = currentRow.getItems().length;\n\n\t}\n\n\t// We need to clean up the bottom container padding\n\t// First remove the height added for box spacing\n\tlayoutData._containerHeight = layoutData._containerHeight - layoutConfig.boxSpacing.vertical;\n\t// Then add our bottom container padding\n\tlayoutData._containerHeight = layoutData._containerHeight + layoutConfig.containerPadding.bottom;\n\n\treturn {\n\t\tcontainerHeight: layoutData._containerHeight,\n\t\twidowCount: layoutConfig._widowCount,\n\t\tboxes: layoutData._layoutItems\n\t};\n\n}\n\n/**\n * Takes in a bunch of box data and config. Returns\n * geometry to lay them out in a justified view.\n *\n * @method covertSizesToAspectRatios\n * @param sizes {Array} Array of objects with widths and heights\n * @return {Array} A list of aspect ratios\n */\n\nmodule.exports = function (input, config) {\n\tvar layoutConfig = {};\n\tvar layoutData = {};\n\n\t// Defaults\n\tvar defaults = {\n\t\tcontainerWidth: 1060,\n\t\tcontainerPadding: 10,\n\t\tboxSpacing: 10,\n\t\ttargetRowHeight: 320,\n\t\ttargetRowHeightTolerance: 0.25,\n\t\tmaxNumRows: Number.POSITIVE_INFINITY,\n\t\tforceAspectRatio: false,\n\t\tshowWidows: true,\n\t\tfullWidthBreakoutRowCadence: false,\n\t\twidowLayoutStyle: 'left'\n\t};\n\n\tvar containerPadding = {};\n\tvar boxSpacing = {};\n\n\tconfig = config || {};\n\n\t// Merge defaults and config passed in\n\tlayoutConfig = Object.assign(defaults, config);\n\n\t// Sort out padding and spacing values\n\tcontainerPadding.top = (!isNaN(parseFloat(layoutConfig.containerPadding.top))) ? layoutConfig.containerPadding.top : layoutConfig.containerPadding;\n\tcontainerPadding.right = (!isNaN(parseFloat(layoutConfig.containerPadding.right))) ? layoutConfig.containerPadding.right : layoutConfig.containerPadding;\n\tcontainerPadding.bottom = (!isNaN(parseFloat(layoutConfig.containerPadding.bottom))) ? layoutConfig.containerPadding.bottom : layoutConfig.containerPadding;\n\tcontainerPadding.left = (!isNaN(parseFloat(layoutConfig.containerPadding.left))) ? layoutConfig.containerPadding.left : layoutConfig.containerPadding;\n\tboxSpacing.horizontal = (!isNaN(parseFloat(layoutConfig.boxSpacing.horizontal))) ? layoutConfig.boxSpacing.horizontal : layoutConfig.boxSpacing;\n\tboxSpacing.vertical = (!isNaN(parseFloat(layoutConfig.boxSpacing.vertical))) ? layoutConfig.boxSpacing.vertical : layoutConfig.boxSpacing;\n\n\tlayoutConfig.containerPadding = containerPadding;\n\tlayoutConfig.boxSpacing = boxSpacing;\n\n\t// Local\n\tlayoutData._layoutItems = [];\n\tlayoutData._awakeItems = [];\n\tlayoutData._inViewportItems = [];\n\tlayoutData._leadingOrphans = [];\n\tlayoutData._trailingOrphans = [];\n\tlayoutData._containerHeight = layoutConfig.containerPadding.top;\n\tlayoutData._rows = [];\n\tlayoutData._orphans = [];\n\tlayoutConfig._widowCount = 0;\n\n\t// Convert widths and heights to aspect ratios if we need to\n\treturn computeLayout(layoutConfig, layoutData, input.map(function (item) {\n\t\tif (item.width && item.height) {\n\t\t\treturn { aspectRatio: item.width / item.height };\n\t\t} else {\n\t\t\treturn { aspectRatio: item };\n\t\t}\n\t}));\n};\n","// get image dimensions\n// thanks https://gist.github.com/dimsemenov/5382856\nfunction getImgDimensions(img, cb) {\n  let interval;\n  let hasSize = false;\n  let addedListeners = false;\n\n  const onHasSize = () => {\n    if (hasSize) {\n      cb(hasSize);\n      return;\n    }\n\n    // check for non-zero, non-undefined naturalWidth\n    if (!img.naturalWidth) {\n      return;\n    }\n\n    hasSize = {\n      width: img.naturalWidth,\n      height: img.naturalHeight,\n    };\n    cb(hasSize);\n\n    clearInterval(interval);\n    if (addedListeners) {\n      // eslint-disable-next-line no-use-before-define\n      removeListeners();\n    }\n  };\n  const onLoaded = () => {\n    onHasSize();\n  };\n  const onError = () => {\n    onHasSize();\n  };\n  const checkSize = () => {\n    if (0 < img.naturalWidth) {\n      onHasSize();\n    }\n  };\n  const addListeners = () => {\n    addedListeners = true;\n    img.addEventListener('load', onLoaded);\n    img.addEventListener('error', onError);\n  };\n  const removeListeners = () => {\n    addedListeners = false;\n    img.removeEventListener('load', onLoaded);\n    img.removeEventListener('error', onError);\n  };\n\n  checkSize();\n\n  if (!hasSize) {\n    addListeners();\n    interval = setInterval(checkSize, 100);\n  }\n}\n\nexport default getImgDimensions;\n","import { debounce } from 'throttle-debounce';\nimport rafSchd from 'raf-schd';\nimport justifiedLayout from 'justified-layout';\n\nimport domReady from './utils/ready';\nimport global from './utils/global';\nimport getImgDimensions from './utils/get-img-dimensions';\n\n// list with all fjGallery instances\n// need to render all in one scroll/resize event\nconst fjGalleryList = [];\n\nconst updateFjGallery = rafSchd(() => {\n  fjGalleryList.forEach((item) => {\n    item.resize();\n  });\n});\n\nglobal.addEventListener('resize', updateFjGallery);\nglobal.addEventListener('orientationchange', updateFjGallery);\nglobal.addEventListener('load', updateFjGallery);\ndomReady(() => {\n  updateFjGallery();\n});\n\nlet instanceID = 0;\n\n// fjGallery class\nclass FJGallery {\n  constructor(container, userOptions) {\n    const self = this;\n\n    self.instanceID = instanceID;\n    instanceID += 1;\n\n    self.$container = container;\n\n    self.images = [];\n\n    self.defaults = {\n      itemSelector: '.fj-gallery-item',\n      imageSelector: 'img',\n      gutter: 10, // supports object like `{ horizontal: 10, vertical: 10 }`.\n      rowHeight: 320,\n      rowHeightTolerance: 0.25, // [0, 1]\n      maxRowsCount: Number.POSITIVE_INFINITY,\n      lastRow: 'left', // left, center, right, hide\n      transitionDuration: '0.3s',\n      calculateItemsHeight: false,\n      resizeDebounce: 100,\n      isRtl: 'rtl' === self.css(self.$container, 'direction'),\n\n      // events\n      onInit: null, // function() {}\n      onDestroy: null, // function() {}\n      onAppendImages: null, // function() {}\n      onBeforeJustify: null, // function() {}\n      onJustify: null, // function() {}\n    };\n\n    // prepare data-options\n    const dataOptions = self.$container.dataset || {};\n    const pureDataOptions = {};\n    Object.keys(dataOptions).forEach((key) => {\n      const loweCaseOption = key.substr(0, 1).toLowerCase() + key.substr(1);\n      if (loweCaseOption && 'undefined' !== typeof self.defaults[loweCaseOption]) {\n        pureDataOptions[loweCaseOption] = dataOptions[key];\n      }\n    });\n\n    self.options = {\n      ...self.defaults,\n      ...pureDataOptions,\n      ...userOptions,\n    };\n\n    self.pureOptions = {\n      ...self.options,\n    };\n\n    // debounce for resize\n    self.resize = debounce(self.options.resizeDebounce, self.resize);\n    self.justify = rafSchd(self.justify.bind(self));\n\n    self.init();\n  }\n\n  // add styles to element\n  // eslint-disable-next-line class-methods-use-this\n  css(el, styles) {\n    if ('string' === typeof styles) {\n      return global.getComputedStyle(el).getPropertyValue(styles);\n    }\n\n    Object.keys(styles).forEach((key) => {\n      el.style[key] = styles[key];\n    });\n    return el;\n  }\n\n  // set temporary transition with event listener\n  applyTransition($item, properties) {\n    const self = this;\n\n    // Remove previous event listener\n    self.onTransitionEnd($item)();\n\n    // Add transitions\n    self.css($item, {\n      'transition-property': properties.join(', '),\n      'transition-duration': self.options.transitionDuration,\n    });\n\n    // Add event listener\n    $item.addEventListener('transitionend', self.onTransitionEnd($item, properties), false);\n  }\n\n  onTransitionEnd($item) {\n    const self = this;\n\n    return () => {\n      self.css($item, {\n        'transition-property': '',\n        'transition-duration': '',\n      });\n\n      $item.removeEventListener('transitionend', self.onTransitionEnd($item));\n    };\n  }\n\n  // add to fjGallery instances list\n  addToFjGalleryList() {\n    fjGalleryList.push(this);\n    updateFjGallery();\n  }\n\n  // remove from fjGallery instances list\n  removeFromFjGalleryList() {\n    const self = this;\n\n    fjGalleryList.forEach((item, key) => {\n      if (item.instanceID === self.instanceID) {\n        fjGalleryList.splice(key, 1);\n      }\n    });\n  }\n\n  init() {\n    const self = this;\n\n    self.appendImages(self.$container.querySelectorAll(self.options.itemSelector));\n\n    self.addToFjGalleryList();\n\n    // call onInit event\n    if (self.options.onInit) {\n      self.options.onInit.call(self);\n    }\n  }\n\n  // append images\n  appendImages($images) {\n    const self = this;\n\n    // check if jQuery\n    if (global.jQuery && $images instanceof global.jQuery) {\n      $images = $images.get();\n    }\n\n    if (!$images || !$images.length) {\n      return;\n    }\n\n    $images.forEach(($item) => {\n      // if $images is jQuery, for some reason in this array there is undefined item, that not a DOM,\n      // so we need to check for $item.querySelector.\n      if ($item && !$item.fjGalleryImage && $item.querySelector) {\n        const $image = $item.querySelector(self.options.imageSelector);\n\n        if ($image) {\n          $item.fjGalleryImage = self;\n          const data = {\n            $item,\n            $image,\n            width: parseFloat($image.getAttribute('width')) || false,\n            height: parseFloat($image.getAttribute('height')) || false,\n            loadSizes() {\n              const itemData = this;\n              getImgDimensions($image, (dimensions) => {\n                if (itemData.width !== dimensions.width || itemData.height !== dimensions.height) {\n                  itemData.width = dimensions.width;\n                  itemData.height = dimensions.height;\n                  self.resize();\n                }\n              });\n            },\n          };\n          data.loadSizes();\n\n          self.images.push(data);\n        }\n      }\n    });\n\n    // call onAppendImages event\n    if (self.options.onAppendImages) {\n      self.options.onAppendImages.call(self, [$images]);\n    }\n\n    self.justify();\n  }\n\n  // justify images\n  justify() {\n    const self = this;\n    const justifyArray = [];\n\n    self.justifyCount = (self.justifyCount || 0) + 1;\n\n    // call onBeforeJustify event\n    if (self.options.onBeforeJustify) {\n      self.options.onBeforeJustify.call(self);\n    }\n\n    self.images.forEach((data) => {\n      if (data.width && data.height) {\n        justifyArray.push(data.width / data.height);\n      }\n    });\n\n    const justifiedOptions = {\n      containerWidth: self.$container.getBoundingClientRect().width,\n      containerPadding: {\n        top: parseFloat(self.css(self.$container, 'padding-top')) || 0,\n        right: parseFloat(self.css(self.$container, 'padding-right')) || 0,\n        bottom: parseFloat(self.css(self.$container, 'padding-bottom')) || 0,\n        left: parseFloat(self.css(self.$container, 'padding-left')) || 0,\n      },\n      boxSpacing: self.options.gutter,\n      targetRowHeight: self.options.rowHeight,\n      targetRowHeightTolerance: self.options.rowHeightTolerance,\n      maxNumRows: self.options.maxRowsCount,\n      showWidows: 'hide' !== self.options.lastRow,\n    };\n    const justifiedData = justifiedLayout(justifyArray, justifiedOptions);\n\n    // Align last row\n    if (\n      justifiedData.widowCount &&\n      ('center' === self.options.lastRow || 'right' === self.options.lastRow)\n    ) {\n      const lastItemData = justifiedData.boxes[justifiedData.boxes.length - 1];\n      let gapSize = justifiedOptions.containerWidth - lastItemData.width - lastItemData.left;\n\n      if ('center' === self.options.lastRow) {\n        gapSize /= 2;\n      }\n      if ('right' === self.options.lastRow) {\n        gapSize -= justifiedOptions.containerPadding.right;\n      }\n\n      for (let i = 1; i <= justifiedData.widowCount; i += 1) {\n        justifiedData.boxes[justifiedData.boxes.length - i].left =\n          justifiedData.boxes[justifiedData.boxes.length - i].left + gapSize;\n      }\n    }\n\n    // RTL compatibility\n    if (self.options.isRtl) {\n      justifiedData.boxes.forEach((boxData, i) => {\n        justifiedData.boxes[i].left =\n          justifiedOptions.containerWidth -\n          justifiedData.boxes[i].left -\n          justifiedData.boxes[i].width -\n          justifiedOptions.containerPadding.right +\n          justifiedOptions.containerPadding.left;\n      });\n    }\n\n    let i = 0;\n    let additionalTopOffset = 0;\n    const rowsMaxHeight = {};\n\n    // Set image sizes.\n    self.images.forEach((data, imgI) => {\n      if (justifiedData.boxes[i] && data.width && data.height) {\n        // calculate additional offset based on actual items height.\n        if (\n          self.options.calculateItemsHeight &&\n          'undefined' === typeof rowsMaxHeight[justifiedData.boxes[i].top] &&\n          Object.keys(rowsMaxHeight).length\n        ) {\n          additionalTopOffset +=\n            rowsMaxHeight[Object.keys(rowsMaxHeight).pop()] - justifiedData.boxes[imgI - 1].height;\n        }\n\n        if (self.options.transitionDuration && 1 < self.justifyCount) {\n          self.applyTransition(data.$item, ['transform']);\n        }\n\n        self.css(data.$item, {\n          display: '',\n          position: 'absolute',\n          transform: `translateX(${justifiedData.boxes[i].left}px) translateY(${\n            justifiedData.boxes[i].top + additionalTopOffset\n          }px) translateZ(0)`,\n          width: `${justifiedData.boxes[i].width}px`,\n        });\n\n        // calculate actual items height.\n        if (self.options.calculateItemsHeight) {\n          const rect = data.$item.getBoundingClientRect();\n\n          if (\n            'undefined' === typeof rowsMaxHeight[justifiedData.boxes[i].top] ||\n            rowsMaxHeight[justifiedData.boxes[i].top] < rect.height\n          ) {\n            rowsMaxHeight[justifiedData.boxes[i].top] = rect.height;\n          }\n        }\n\n        i += 1;\n      } else {\n        self.css(data.$item, {\n          display: 'none',\n        });\n      }\n    });\n\n    // increase additional offset based on the latest row items height.\n    if (self.options.calculateItemsHeight && Object.keys(rowsMaxHeight).length) {\n      additionalTopOffset +=\n        rowsMaxHeight[Object.keys(rowsMaxHeight).pop()] -\n        justifiedData.boxes[justifiedData.boxes.length - 1].height;\n    }\n\n    if (self.options.transitionDuration) {\n      self.applyTransition(self.$container, ['height']);\n    }\n\n    // Set container height.\n    self.css(self.$container, {\n      height: `${justifiedData.containerHeight + additionalTopOffset}px`,\n    });\n\n    // call onJustify event\n    if (self.options.onJustify) {\n      self.options.onJustify.call(self);\n    }\n  }\n\n  // update options and resize gallery items\n  updateOptions(options) {\n    const self = this;\n    self.options = {\n      ...self.options,\n      ...options,\n    };\n    self.justify();\n  }\n\n  destroy() {\n    const self = this;\n\n    self.removeFromFjGalleryList();\n\n    self.justifyCount = 0;\n\n    // call onDestroy event\n    if (self.options.onDestroy) {\n      self.options.onDestroy.call(self);\n    }\n\n    // remove styles.\n    self.css(self.$container, {\n      height: '',\n      transition: '',\n    });\n    self.images.forEach((data) => {\n      self.css(data.$item, {\n        position: '',\n        transform: '',\n        transition: '',\n        width: '',\n        height: '',\n      });\n    });\n\n    // delete fjGalleryImage instance from images\n    self.images.forEach((val) => {\n      delete val.$item.fjGalleryImage;\n    });\n\n    // delete fjGallery instance from container\n    delete self.$container.fjGallery;\n  }\n\n  resize() {\n    const self = this;\n\n    self.justify();\n  }\n}\n\n// global definition\nconst fjGallery = function (items, options, ...args) {\n  // check for dom element\n  // thanks: http://stackoverflow.com/questions/384286/javascript-isdom-how-do-you-check-if-a-javascript-object-is-a-dom-object\n  if (\n    'object' === typeof HTMLElement\n      ? items instanceof HTMLElement\n      : items &&\n        'object' === typeof items &&\n        null !== items &&\n        1 === items.nodeType &&\n        'string' === typeof items.nodeName\n  ) {\n    items = [items];\n  }\n\n  const len = items.length;\n  let k = 0;\n  let ret;\n\n  for (k; k < len; k += 1) {\n    if ('object' === typeof options || 'undefined' === typeof options) {\n      if (!items[k].fjGallery) {\n        // eslint-disable-next-line new-cap\n        items[k].fjGallery = new FJGallery(items[k], options);\n      }\n    } else if (items[k].fjGallery) {\n      // eslint-disable-next-line prefer-spread\n      ret = items[k].fjGallery[options].apply(items[k].fjGallery, args);\n    }\n    if ('undefined' !== typeof ret) {\n      return ret;\n    }\n  }\n\n  return items;\n};\nfjGallery.constructor = FJGallery;\n\nexport default fjGallery;\n","function ready(callback) {\n  if ('complete' === document.readyState || 'interactive' === document.readyState) {\n    // Already ready or interactive, execute callback\n    callback();\n  } else {\n    document.addEventListener('DOMContentLoaded', callback, {\n      capture: true,\n      once: true,\n      passive: true,\n    });\n  }\n}\n\nexport default ready;\n","import global from './utils/global';\nimport fjGallery from './fjGallery';\n\nconst $ = global.jQuery;\n\n// jQuery support\nif ('undefined' !== typeof $) {\n  // add data to jQuery .data('fjGallery')\n  const oldInit = fjGallery.constructor.prototype.init;\n  fjGallery.constructor.prototype.init = function () {\n    $(this.$container).data('fjGallery', this);\n\n    if (oldInit) {\n      oldInit.call(this);\n    }\n  };\n\n  // remove data from jQuery .data('fjGallery')\n  const oldDestroy = fjGallery.constructor.prototype.destroy;\n  fjGallery.constructor.prototype.destroy = function () {\n    if (this.$container) {\n      $(this.$container).removeData('fjGallery');\n    }\n    if (oldDestroy) {\n      oldDestroy.call(this);\n    }\n  };\n\n  const $Plugin = function (...args) {\n    Array.prototype.unshift.call(args, this);\n    const res = fjGallery.apply(global, args);\n    return 'object' !== typeof res ? res : this;\n  };\n  $Plugin.constructor = fjGallery.constructor;\n\n  // no conflict\n  const old$Plugin = $.fn.fjGallery;\n  $.fn.fjGallery = $Plugin;\n  $.fn.fjGallery.noConflict = function () {\n    $.fn.fjGallery = old$Plugin;\n    return this;\n  };\n}\n\nexport default fjGallery;\n"],"names":["win","window","global","self","global$1","delay","callback","options","timeoutID","_ref$noTrailing","noTrailing","_ref$noLeading","noLeading","_ref$debounceMode","debounceMode","undefined","cancelled","lastExec","clearExistingTimeout","clearTimeout","wrapper","_len","arguments","length","arguments_","Array","_key","this","elapsed","Date","now","exec","apply","clear","setTimeout","cancel","_ref2$upcomingOnly","upcomingOnly","rafSchd","fn","lastArgs","frameId","wrapperFn","args","requestAnimationFrame","cancelAnimationFrame","rowModule","exports","params","top","left","width","spacing","targetRowHeight","targetRowHeightTolerance","minAspectRatio","maxAspectRatio","edgeCaseMinRowHeight","edgeCaseMaxRowHeight","widowLayoutStyle","isBreakoutRow","items","height","prototype","addItem","itemData","previousRowWidthWithoutSpacing","previousAspectRatio","previousTargetAspectRatio","newItems","concat","rowWidthWithoutSpacing","newAspectRatio","reduce","sum","item","aspectRatio","targetAspectRatio","push","completeLayout","Object","assign","Math","abs","isLayoutComplete","newHeight","clampedToNativeRatio","clampedHeight","errorWidthPerItem","roundedCumulativeErrors","centerOffset","itemWidthSum","indexOf","max","min","forEach","map","i","round","forceComplete","fitToWidth","rowHeight","getItems","Row","require$$0","createNewRow","layoutConfig","layoutData","fullWidthBreakoutRowCadence","_rows","_containerHeight","containerPadding","containerWidth","right","boxSpacing","horizontal","rightToLeft","addRow","row","_layoutItems","vertical","lib","input","config","defaults","maxNumRows","Number","POSITIVE_INFINITY","forceAspectRatio","showWidows","isNaN","parseFloat","bottom","_awakeItems","_inViewportItems","_leadingOrphans","_trailingOrphans","_orphans","_widowCount","itemLayoutData","itemAdded","currentRow","nextToLastRowHeight","laidOutItems","forcedAspectRatio","some","Error","containerHeight","widowCount","boxes","computeLayout","getImgDimensions","img","cb","interval","hasSize","addedListeners","onHasSize","naturalWidth","naturalHeight","clearInterval","removeListeners","onLoaded","onError","checkSize","removeEventListener","addEventListener","setInterval","fjGalleryList","updateFjGallery","resize","document","readyState","capture","once","passive","instanceID","FJGallery","constructor","container","userOptions","$container","images","itemSelector","imageSelector","gutter","rowHeightTolerance","maxRowsCount","lastRow","transitionDuration","calculateItemsHeight","resizeDebounce","isRtl","css","onInit","onDestroy","onAppendImages","onBeforeJustify","onJustify","dataOptions","dataset","pureDataOptions","keys","key","loweCaseOption","substr","toLowerCase","pureOptions","debounce","justify","bind","init","el","styles","getComputedStyle","getPropertyValue","style","applyTransition","$item","properties","onTransitionEnd","join","addToFjGalleryList","removeFromFjGalleryList","splice","appendImages","querySelectorAll","call","$images","jQuery","get","fjGalleryImage","querySelector","$image","data","getAttribute","loadSizes","dimensions","justifyArray","justifyCount","justifiedOptions","getBoundingClientRect","justifiedData","justifiedLayout","lastItemData","gapSize","boxData","additionalTopOffset","rowsMaxHeight","imgI","pop","display","position","transform","rect","updateOptions","destroy","transition","val","fjGallery","HTMLElement","nodeType","nodeName","len","ret","k","$","oldInit","oldDestroy","removeData","$Plugin","unshift","res","old$Plugin","noConflict"],"mappings":"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"}